//https://www.codeproject.com/Articles/5308420/Comparison-of-Sorting-Algorithms


Welcome to our Comparison on Sorting Algorithms Article. Here, we'll be comparing the various sorting Algorithms out there on the basic of several factors.

Time Complexity
Space Complexity
Stable/Unstable (stable maintains order of same val elements)

We’ll top it all of by trying to describe where each Algorithm is best suited, and their strong and weak points. Every Algorithm is unique, and performs best under certain circumstances unique to it.

Comparison of Time Complexity
A table that show’s the time complexities for some of the most commonly used Sorting Algorithms. Time complexity is the first thing that you need to be checking when comparing two sorting algorithms. The lower the time complexity, the better.

Sorting Algorithm	Average Case	Best Case	Worst Case
Bubble Sort	O(n^2)	O(n)	O(n^2)
Insertion Sort	O(n^2)	O(n)	O(n^2)
Selection Sort	O(n^2)	O(n^2)	O(n^2)
Quick Sort	O(n.log(n))	O(n.log(n))	O(n^2)
Merge Sort	O(n.log(n))	O(n.log(n))	O(n.log(n))
Heap Sort	O(n.log(n))	O(n.log(n))	O(n.log(n))
Counting Sort	O(n+k)	O(n+k)	O(n+k)
Radix Sort	O(n*k)	O(n*k)	O(n*k)
Bucket Sort	O(n+k)	O(n+k)	O(n^2)

We’ve used a color scheme in the table above, to help with our Comparison of Sorting Algorithms. Red is the worst, under which the O(n2) Algorithms lie. The O(n.log(n)) Algorithms are next, which are the middle ground. The best time complexity is O(n), which is the fastest Algorithm can be.

Later when we do the actual field tests, you can use this table as reference. You will notice how much of an impact time complexity has on performance.

Comparison of Space Complexity
While speed is important and usually your top priority, sometimes in places with memory constraints, Algorithms with low memory costs are preferred.

The below table shows the Space Complexity for the various Sorting Algorithms. You might notice, that the Algorithms with higher space complexities are those which are “out of place” and the ones with the lowest, are in-place. This is of course, because Out of Place Algorithms create extra arrays to store the data in, while In-place uses the same array.

It goes without saying, that the best Space Complexity is O(1).

Sorting Algorithm	Space Complexity

Bubble Sort	O(1)
Insertion Sort	O(1)
Selection Sort	O(1)
Quick Sort	O(log(n))
Merge Sort	O(n)
Heap Sort	O(1)
Counting Sort	O(k)
Radix Sort	O(n + k)
Bucket Sort	O(n)
Stable and Unstable Algorithms

This is a rather niche use, and only makes an actual difference in certain types of data. However, it remains an important requirement that is needed for these certain scenarios.

Sorting Algorithm	Stable Sort?

Bubble Sort	Yes
Insertion Sort	Yes
Selection Sort	No
Quick Sort	No
Merge Sort	Yes
Heap Sort	No
Counting Sort	Yes
Radix Sort	Yes
Bucket Sort	Yes

Is it important to note however, that you can usually create stable versions of the above Algorithms. The ones being referred to in the image above, are the “Classic” versions of the Algorithm.